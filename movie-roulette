#! /usr/bin/env perl

use strict;
use warnings;

use REST::Client;
use JSON;
use Getopt::Long;

# globals
my (
    $cache_file,
    $cache_ttl,     # time to live
);

# options
my (
    $verbose,
    $server,
    $refresh_cache,
    $item_type,
);

# should be in main (TODO)
my (
    $api_key,   
    $client,
    $endpoint,
    $response_code,
    $response_content,
    $json,
    $total_count,
    $random_index,
    $movie,
    $title,
    $year,
    $input,
    $item_id,
    $url,
);

############
# prelim's #
############

# seed the random generator
srand;

### cache config
# this set-up should happen somewhere special

# the location & name of the cache file
$cache_file = "jellyfin_roulette.data";     # should be in /tmp/
$cache_ttl = 0.002;                             # number of days before refresh

### options ###

# opts here to set whether
# - movies or series
# - the server
# - force cache reload

# options defaults:
$verbose = 0;
$server = 'http://blue.home:8096';
$item_type = "Movie";                   #Movie or Series
$refresh_cache = 0;

GetOptions (
    "verbose|v"     => \$verbose,
    "server|s=s"    => \$server,
    "type|t=s"      => \$item_type,
    "refresh|r"     => \$refresh_cache
);

### TODO
# a usage/help flag

# check:
# server should have right form
# basic af: http(s)://something.something
if (!($server =~ m#^https?://.*\..*#)) {        # m for custom deliminator
    die ("invalid server address.");
}
# type should be movie or series (or whatever)...
if ($item_type =~ /^movies?$/i) {
    $item_type = "Movie";
} 
elsif ($item_type =~ /^series$/i) {
    $item_type = "Series";
} 
else {
    die("invalid media format requested.");
}

print "verbose mode on\n" if ($verbose);

#############
# load data #
#############

$json = load_cache() unless ($refresh_cache);

unless ($json) {

    print "polling the server\n" if ($verbose);
    
    ### server access ###

    # get api key from environment
    $api_key = $ENV{"JELLYFIN"};

    # set-up restful client
    $client = REST::Client->new();

    print "server = $server\n" if ($verbose);
    $client->setHost($server);      

    # add identity for authorisation
    $client->addHeader('Accept', 'application/json');
    $client->addHeader('X-Emby-Token', $api_key);

    # now set the api end point for the request
    $endpoint = "/Items?IncludeItemTypes=$item_type&Recursive=true";
    print "request = $endpoint\n" if ($verbose);

    ################
    # poll the api #
    ################

    ### TODO
    # this may take a while
    # it would be cool if there was a little loader while we waited
    # i.e. fork off the process

    $client->GET($endpoint);

    $response_code = $client->responseCode();
    print "received response = $response_code\n" if ($verbose);

    if ($response_code == 200) {

        $response_content = $client->responseContent();
        $json = decode_json($response_content);
        save_cache($json);
    }
    elsif ($response_code == 401) {
        print "authorisation issue!\n"
    }
    else {
        print "bad response from server.\n";
    }
}

#################
# get the movie #
#################

$total_count = $json->{TotalRecordCount} // 0;    # (if undef set to zero)

if ($total_count != 0) {
    while (1) {
        $random_index = int(rand($total_count));

        $movie = $json->{Items}[$random_index];

        if ($movie) {
            $title = $movie->{Name} // "unknown";
            $year  = $movie->{ProductionYear} // "unknown";

            ### this is it:
            print "$title ($year)\n";
        }

        print "watch? [y/N]: ";
        chomp($input = <STDIN>);
        if (($input =~ /^y$/i)) {
            # check vlc exists
            check_vlc_installed();

            # get the movie url and load vlc
            $item_id = $movie->{Id};
            print "item id = $item_id\n" if ($verbose);
            
            $url = "$server/Videos/$item_id/".
                        "stream?Static=true&api_key=$api_key";

            print "url = $url\n" if ($verbose);

            # start vlc media player
            system("vlc", $url);
            # when vlc's done, what should we do...
            # should really jump to "go again?"
        }
        else {
            print "go again? [Y/n]: ";
            chomp($input = <STDIN>);
            last unless ($input =~ /^y?$/i);
        }
        # could more info be an option?
    }
}
else {
    print "no records available!\n";
}

###############
# subroutines #
###############

sub check_vlc_installed {
    # kill this program if no vlc available

    my $vlc_install;
    chomp($vlc_install = `which vlc 2>/dev/null`);  
    # pipe 2 out since don't care if which fails, just that vlc exists
    print "vlc install found at: $vlc_install\n" if ($verbose);
    die("no vlc found!") unless (-x $vlc_install);  
}

sub load_cache {
    # returns nothing if no cache
    # otherwise, the data in json form

    print "loading cache\n" if ($verbose);

    return unless (-e $cache_file);
    
    # check ttl of file
    return if (-M $cache_file > $cache_ttl);

    open(my $fh, $cache_file) || return;
    my $data = <$fh>;
    close $fh;
    return decode_json($data);
}

sub save_cache {

    print "saving cache\n" if ($verbose);

    my ($data) = @_;
    open(my $fh, ">".$cache_file) || warn("failed to create cache!");
    print $fh encode_json($data);
    close $fh;
}

### TODO
# a main function