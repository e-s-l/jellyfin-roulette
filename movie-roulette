#! /usr/bin/env perl

use strict;
use warnings;

use REST::Client;
use JSON;
use Getopt::Long;

# globals
my (
        $cache_file
);

# options
my (
        $verbose,
        $server,
        $refresh_cache,
        $item_type,
);

# should be in main (TODO)
my (
        $api_key,   
        $client,
        $endpoint,
        $response_code,
        $response_content,
        $json,
        $total_count,
        $random_index,
        $random_url,
        $movie,
        $title,
        $year,
        $input,
        $item_id,
        $url,
);

############
# prelim's #
############

# seed the random generator
srand;

# the location & name of the cache file
$cache_file = "jellyfin_roulette.data";       # should be in /tmp/

### options ###

# opts here to set whether
# - movies or series
# - the server
# - force cache reload

# options defaults:
$verbose = 0;
$server = 'http://blue.home:8096';
$item_type = "Movie";                   #Movie or Series
$refresh_cache = 0;

GetOptions (
        "verbose|v"     => \$verbose,
        "server|s=s"    => \$server,
        "type|t=s"      => \$item_type,
        "refresh|r"     => \$refresh_cache
);

### TODO
# a usage/help flag

# check:
# server should have right form
# basic af: http(s)://something.something
if (!($server =~ m#^https?://.*\..*#)) {                # m for custom deliminator
        die ("invalid server address.");
}
# type should be movie or series (or whatever)...
if ($item_type =~ /^movies?$/i) {
        $item_type = "Movie";
} 
elsif ($item_type =~ /^series$/i) {
        $item_type = "Series";
} else {
        die("invalid media format requested.");
}

if ($verbose) {print "verbose mode on\n"};

#############
# load data #
#############

unless ($refresh_cache) {
        if ($verbose) {print "loading cache file\n"};
        $json = load_cache();
}

unless ($json) {

        if ($verbose) {print "no cache, polling the server\n"};
        
        ### server access ###

        # get api key from environment
        $api_key = $ENV{"JELLYFIN"};

        # set-up restful client
        $client = REST::Client->new();

        if ($verbose) {print "server = $server\n"};
        $client->setHost($server);      

        # add identity for authorisation
        $client->addHeader('Accept', 'application/json');
        $client->addHeader('X-Emby-Token', $api_key);

        # now set the api end point for the request
        $endpoint = "/Items?IncludeItemTypes=$item_type&Recursive=true";
        if ($verbose) {print "request = $endpoint\n"};

        ################
        # poll the api #
        ################

        ### TODO
        # this may take a while
        # it would be cool if there was a little loader while we waited
        # i.e. fork off the process

        $client->GET($endpoint);

        $response_code = $client->responseCode();
        if ($verbose) {print "received response = $response_code\n"};

        if ($response_code == 200) {

                $response_content = $client->responseContent();
                $json = decode_json($response_content);
                save_cache($json);

        }
        elsif ($response_code == 401) {
                print "authorisation issue!\n"
        }
        else {
                print "bad response from server.\n"
        }
}

#################

$total_count = $json->{TotalRecordCount} // 0;        # (if undef set to zero)

if ($total_count != 0) {
        
        while (1) {
                $random_index = int(rand($total_count));

                        $movie = $json->{Items}[$random_index];

                        if ($movie) {
                                $title = $movie->{Name} // 'Unknown';
                                $year  = $movie->{ProductionYear} // 'N/A';
                                print "$title ($year)\n";
                        }

                        print "watch? [y/N]: ";
                        chomp($input = <STDIN>);
                        if (($input =~ /^y$/i)) {

                                # check vlc exists
                                check_vlc_installed();

                                # get the movie url and load vlc
                                $item_id = $movie->{Id};
                                if ($verbose) {print "item id = $item_id\n"};
                                
                                $url = "$server/Videos/$item_id/stream?Static=true&api_key=$api_key";
                                # or
                                #$url = "$server/Videos/$item_id/main.m3u8?api_key=$api_key";

                                if ($verbose) {print "url = $url\n"};
                                system("vlc", $url);
                                last;
                        }
                        else {
                                print "go again? [Y/n]: ";
                                chomp($input = <STDIN>);
                                if (!($input =~ /^y?$/i)) {
                                        last;
                                }
                        }
                        # could more info be an option?
        }
}
else print "no records available!\n";

###############
# subroutines #
###############

sub check_vlc_installed {
        # kill this program if no vlc available

        my $vlc_install;
        chomp($vlc_install = `which vlc 2>/dev/null`);      # don't care if it fails

        if ($verbose) {print "vlc install found at: $vlc_install\n"};

        if (!-x $vlc_install) {
                die("no vlc found!")
        }      
}

sub load_cache {
        # returns nothing if no cache
        # otherwise, the data in json form

        unless (-e $cache_file) {return};
        
        ### TODO
        # check ttl of file

        open(my $fh, $cache_file) || return;
        my $data = <$fh>;
        close $fh;
        return decode_json($data);
}

sub save_cache {
        my ($data) = @_;
        open(my $fh, ">".$cache_file) || warn("failed to create cache!");
        print $fh encode_json($data);
        close $fh;
}

### TODO
# a main function