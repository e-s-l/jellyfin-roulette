#! /usr/bin/env perl

use strict;
use warnings;

use REST::Client;
use JSON;
use Getopt::Long;

# globals
my (
    $cache_file,
    $cache_ttl,     # time to live
    $api_key,   
);

# options
my (
    $verbose,
    $server,
    $refresh_cache,
    $item_type,
);

# should be in main (TODO)
my (
    $endpoint,
    $response_code,
    $response_content,
    $json,
    $total_count,
    $random_index,
    $item,          # item is movie or series
    $title,
    $year,
    $input,
    $item_id,
    $url,
    $client,
);

############
# prelim's #
############

# seed the random generator
srand;

### options ###

# opts here to set whether
# - movies or series
# - the server
# - force cache reload

# options defaults:
$verbose = 0;
$server = 'http://blue.home:8096';
$item_type = "Movie";               #"Movie" or "Series"
$refresh_cache = 0;

GetOptions (
    "verbose|v"     => \$verbose,
    "server|s=s"    => \$server,
    "type|t=s"      => \$item_type,
    "refresh|r"     => \$refresh_cache
);

### TODO
# a usage/help flag

# check:
# server should have right form
# basic af: http(s)://something.something
if (!($server =~ m#^https?://.*\..*#)) {        # m for custom deliminator
    die ("invalid server address.");
}
# type should be movie or series (or whatever)...
if ($item_type =~ /^movies?$/i) {
    $item_type = "Movie";
} 
elsif ($item_type =~ /^series$/i) {
    $item_type = "Series";
} 
else {
    die("invalid media format requested.");
}

print "verbose mode on\n" if ($verbose);


### cache config ###

# this set-up should happen somewhere special

# the location & name of the cache file
$cache_file = "/tmp/jellyfin_roulette_".lc($item_type).".data";

# number of days before refresh
$cache_ttl = 1;

### server access ###

# this will be used in case of downloading a cache
# or polling for series information
# hence initialised here

# get api key from environment
$api_key = $ENV{"JELLYFIN"};

# set-up restful client
$client = REST::Client->new();

print "server = $server\n" if ($verbose);
$client->setHost($server);      

# add identity for authorisation
$client->addHeader('Accept', 'application/json');
$client->addHeader('X-Emby-Token', $api_key);

#############
# load data #
#############

$json = load_cache() unless ($refresh_cache);

unless ($json) {

    print "polling the server\n" if ($verbose);
    
    # now set the api end point for the request
    $endpoint = "/Items?IncludeItemTypes=$item_type&Recursive=true";

    print "request = $endpoint\n" if ($verbose);

    ################
    # poll the api #
    ################

    ### TODO
    # this may take a while
    # it would be cool if there was a little loader while we waited
    # i.e. fork off the process

    $client->GET($endpoint);

    $response_code = $client->responseCode();
    print "received response = $response_code\n" if ($verbose);

    if ($response_code == 200) {

        $response_content = $client->responseContent();
        $json = decode_json($response_content);
        save_cache($json);
    }
    elsif ($response_code == 401) {
        print "authorisation issue!\n"
    }
    else {
        print "bad response from server.\n";
    }
}

#################
# get the movie #
#################

$total_count = $json->{TotalRecordCount} // 0;    # (if undef set to zero)

if ($total_count != 0) {
    while (1) {
        $random_index = int(rand($total_count));

        $item = $json->{Items}[$random_index];

        if ($item) {
            $title = $item->{Name} // "unknown";
            $year  = $item->{ProductionYear} // "unknown";

            ### this is it:
            print "$title ($year)\n";
        }

        print "watch? [y/N]: ";
        chomp($input = <STDIN>);
        if (($input =~ /^y$/i)) {
            # check vlc exists
            check_vlc_installed();

            if ($item_type eq "Movie") {

                # get the movie url
                $item_id = $item->{Id};

            }
            elsif ($item_type eq "Series") {

                ### poll server for series info ###

                $item_id = get_episode_one($client, $item);
            
                ### TODO
                # select a random episode from the series...
            }

            print "item id = $item_id\n" if ($verbose);

            $url = "$server/Videos/$item_id/".
                    "stream?Static=true&api_key=$api_key";
        
            print "url = $url\n" if ($verbose);

            # start vlc media player
            system("vlc", $url);
            # when vlc's done, what should we do...
            # should really jump to "go again?"
        }
        else {
            print "go again? [Y/n]: ";
            chomp($input = <STDIN>);
            last unless ($input =~ /^y?$/i);
        }
        # could more info be an option?
    }
}
else {
    print "no records available!\n";
}

###############
# subroutines #
###############

sub get_episode_one {
    # given the series identified
    # return first episodes id

    my ($client, $item) = @_;

    my $series_name = $item->{Name};
    my $series_id = $item->{Id};

    my $episodes_endpoint = "/Items?IncludeItemTypes=Episode&Recursive=true".
                                "&ParentId=$series_id&SortBy=SortName".
                                    "&SortOrder=Ascending".
                                        "&StartIndex=0&Limit=1";


    $client->GET($episodes_endpoint);

    if ($client->responseCode() == 200) {

        my $episodes_data = decode_json($client->responseContent());
        my $episodes = $episodes_data->{Items};
        return $episodes->[0]{Id};

    } else {
        warn "coudln't access server.\n"
    }
}

sub check_vlc_installed {
    # kill this program if no vlc available

    my $vlc_install;
    chomp($vlc_install = `which vlc 2>/dev/null`);  
    # pipe 2 out since don't care if which fails, just that vlc exists
    print "vlc install found at: $vlc_install\n" if $verbose;
    die("no vlc found!") unless (-x $vlc_install);  
}

sub load_cache {
    # returns nothing if no recent cache
    # otherwise, the data in json form

    print "loading cache\n" if $verbose;

    return unless (-e $cache_file);
    
    # check ttl of file
    return if (-M $cache_file > $cache_ttl);

    open(my $fh, $cache_file) || return;
    my $data = <$fh>;
    close $fh;
    return decode_json($data);
}

sub save_cache {
    # write to file the json data received

    print "saving cache\n" if $verbose;

    my ($data) = @_;
    open(my $fh, ">".$cache_file) || warn("failed to create cache!");
    print $fh encode_json($data);
    close $fh;
}

### TODO
# a main function