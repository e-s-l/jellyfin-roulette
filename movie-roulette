#! /usr/bin/env perl

use strict;
use warnings;

use REST::Client;
use JSON;
use Getopt::Long;

#########
# about #
#########
#
#
#

### TODO
# - a main function
# - a get more info function?
#

### to look into
# - if only loading from cache, sometimes REST client fails...

# globals
my (
    $cache_file,
    $cache_ttl,     # time to live
    $api_key,   
);

# options
my (
    $verbose,
    $server,
    $refresh_cache,
    $item_type,
);

# should be in main (TODO)
my (
    $endpoint,
    $response_code,
    $response_content,
    $json,
    $total_count,
    $random_index,
    $item,          # item is movie or series
    $title,
    $year,
    $input,
    $item_id,
    $client,
);

############
# prelim's #
############

# seed the random generator
srand;

### options ###

# opts here to set whether
# - movies or series
# - the server
# - force cache reload

# options defaults:
$verbose = 0;
$server = 'http://blue.home:8096';
$item_type = "Movie";               #"Movie" or "Series"
$refresh_cache = 0;

GetOptions (
    "verbose|v"     => \$verbose,
    "server|s=s"    => \$server,
    "type|t=s"      => \$item_type,
    "refresh|r"     => \$refresh_cache
);

### TODO
# a usage/help flag

# check:
# server should have right form
# basic af: http(s)://something.something
if (!($server =~ m#^https?://.*\..*#)) {        # m for custom deliminator
    die ("invalid server address.");
}
# type should be movie or series (or whatever)...
if ($item_type =~ /^movies?$/i) {
    $item_type = "Movie";
} 
elsif ($item_type =~ /^series$/i) {
    $item_type = "Series";
} 
else {
    die("invalid media format requested.");
}

print "verbose mode on\n" if ($verbose);

### cache config ###

# the location & name of the cache file
$cache_file = "/tmp/jellyfin_roulette_".lc($item_type).".data";

# number of days before refresh
$cache_ttl = 1;

### server access ###

# this will be used in case of downloading a cache
# or polling for series information
# hence initialised here

# get api key from environment
$api_key = $ENV{"JELLYFIN"};

# set-up restful client
$client = REST::Client->new();

print "server = $server\n" if ($verbose);
$client->setHost($server);      

# add identity for authorisation
$client->addHeader('Accept', 'application/json');
$client->addHeader('X-Emby-Token', $api_key);

#############
# load data #
#############

$json = load_cache() unless ($refresh_cache);

unless ($json) {

    print "polling the server\n" if ($verbose);
    
    # now set the api end point for the request
    $endpoint = "/Items?IncludeItemTypes=$item_type&Recursive=true";

    print "request = $endpoint\n" if ($verbose);

    ################
    # poll the api #
    ################

    ### TODO
    # this may take a while
    # it would be cool if there was a little loader while we waited
    # i.e. fork off the process

    $client->GET($endpoint);

    $response_code = $client->responseCode();
    print "received response = $response_code\n" if ($verbose);

    if ($response_code == 200) {

        $response_content = $client->responseContent();
        $json = decode_json($response_content);
        save_cache($json);
    }
    elsif ($response_code == 401) {
        print "authorisation issue!\n"
    }
    else {
        print "bad response from server.\n";
    }
}

#################
# get the movie #
#################

$total_count = $json->{TotalRecordCount} // 0;    # (if undef set to zero)

if ($total_count != 0) {
    while (1) {
        $random_index = int(rand($total_count));
        $item = $json->{Items}[$random_index];

        if ($item) {
            $title = $item->{Name} // "unknown";
            $year  = $item->{ProductionYear} // "unknown";

            ### this is it:
            print "$title ($year)\n";
        }

        # could more info be an option?

        print "watch? [y/N]: ";
        chomp($input = <STDIN>);
        if (($input =~ /^y$/i)) {

            # check vlc exists
            # or abort now
            check_vlc_installed();

            if ($item_type eq "Movie") {
                # movies are simple, just play 'em

                $item_id = $item->{Id};
                play_video($item_id);
                last;

            }
            elsif ($item_type eq "Series") {
                # if series
                # should ask for first episode 
                # or random episode
                # then after that ask, either
                # next ep? or
                # another?

                my $ep_num; # the current episode
    
                my $episodes_count = get_number_of_episodes($client, $item);
                if ($verbose) {
                    print "number of episodes: ".$episodes_count."\n";
                }

                while(1) {
                    print "ep. num = $ep_num / $episodes_count\n";# if ($verbose);

                    unless (defined $ep_num) {
                        print "ep. 1? [y/N]: ";
                        chomp($input = <STDIN>);
                        if (($input =~ /^y$/i)) {
                            $ep_num = 1;
                        }
                        else {
                            print "random ep.? [Y/n]: ";
                            chomp($input = <STDIN>);
                            if (($input =~ /^y?$/i)) {
                                $ep_num = int(rand($episodes_count));
                            }
                            else {
                                last;
                            }
                        }
                    } else {
                        print "next ep.? [Y/n]: ";
                        chomp($input = <STDIN>);
                        last unless ($input =~ /^y?$/i);
                        ++$ep_num;
                    }
                    if (defined $ep_num && $ep_num <= $episodes_count){
                        $item_id = get_episode($client, $item, $ep_num);
                        play_video($item_id);
                    }
                    else {
                        print("outta ep's!\n");
                        last;
                    }
                }
            }
        }

        print "go again? [Y/n]: ";
        chomp($input = <STDIN>);
        last unless ($input =~ /^y?$/i);
    }
}
else {
    print "no records available!\n";
}

###############
# subroutines #
###############

### poll server for series info ###

sub get_number_of_episodes {
    # given api client and series identifier
    # return the total number of episodes
    #

    my $episodes_count = 0;
    my ($client, $item) = @_;
    my $series_id = $item->{Id};
    my $endpoint = "/Items?IncludeItemTypes=Episodes&Recursive=true&ParentId=$series_id";

    $client->GET($endpoint);
    my $response_code = $client->responseCode();

    if ($response_code == 200) {
        my $data = decode_json($client->responseContent());
        $episodes_count = $data->{TotalRecordCount} // 0;
    } else {
        print "got bad response: $response_code\n" if ($verbose);
    }

    return $episodes_count;
}

sub get_episode {
    # given the series identified
    # return first episodes id

    my ($client, $item, $episode_num) = @_;

    my $start_index;
    # this assumes $start_index corresponds to episode number

    if (defined $episode_num && $episode_num > 0) {
        $start_index = $episode_num - 1;
    }
    else {
        $start_index = 0;
    }

    my $series_name = $item->{Name};
    my $series_id = $item->{Id};

    # this is the endpoint for the first episode of a series
    my $episodes_endpoint = "/Items?IncludeItemTypes=Episode&Recursive=true".
                                "&ParentId=$series_id&SortBy=SortName".
                                    "&SortOrder=Ascending".
                                        "&StartIndex=$start_index&Limit=1";


    $client->GET($episodes_endpoint);

    my $response_code = $client->responseCode();

    if ($response_code == 200) {
        my $episodes_data = decode_json($client->responseContent());
        my $episodes = $episodes_data->{Items};
        return $episodes->[0]{Id};
    } else {
        print "response: $response_code\n";
        warn "couldn't access the server.\n"
    }
}

### video play-back

sub play_video {
    # need to fix this to pass the right variables

    my ($item_id) = @_;
    print "item id = $item_id\n" if ($verbose);

    my $url = "$server/Videos/$item_id/".
                "stream?Static=true&api_key=$api_key";

    print "url = $url\n" if ($verbose);

    # start vlc media player
    if ($verbose) {
        system("vlc", $url);
    } else {
        system("bash", "-c", "vlc '$url' >/dev/null 2>&1");
    }
    # when vlc's done, what should we do...
}


sub check_vlc_installed {
    # kill this program if no vlc available

    my $vlc_install;

    chomp($vlc_install = `which vlc 2>/dev/null`);  
    # pipe 2 out since don't care if which fails, just that vlc exists
    print "vlc install found at: $vlc_install\n" if $verbose;
    die("no vlc found!") unless (-x $vlc_install);  
}

### caches

sub load_cache {
    # returns nothing if no recent cache
    # otherwise, the data in json form

    print "loading cache\n" if $verbose;

    return unless (-e $cache_file);
    
    # check ttl of file
    return if (-M $cache_file > $cache_ttl);

    open(my $fh, $cache_file) || return;
    my $data = <$fh>;
    close $fh;
    return decode_json($data);
}

sub save_cache {
    # write to file the json data received

    print "saving cache\n" if $verbose;

    my ($data) = @_;
    open(my $fh, ">".$cache_file) || warn("failed to create cache!");
    print $fh encode_json($data);
    close $fh;
}
